<HTML>
<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<!-- Created on July, 18  2001 by texi2html 1.64 -->
<!-- 
Written by: Lionel Cons <Lionel.Cons@cern.ch> (original author)
            Karl Berry  <karl@freefriends.org>
            Olaf Bachmann <obachman@mathematik.uni-kl.de>
            and many others.
Maintained by: Olaf Bachmann <obachman@mathematik.uni-kl.de>
Send bugs and suggestions to <texi2html@mathematik.uni-kl.de>
 
-->
<HEAD>
<TITLE>MIT Scheme Reference: Associations</TITLE>

<META NAME="description" CONTENT="MIT Scheme Reference: Associations">
<META NAME="keywords" CONTENT="MIT Scheme Reference: Associations">
<META NAME="resource-type" CONTENT="document">
<META NAME="distribution" CONTENT="global">
<META NAME="Generator" CONTENT="texi2html 1.64">

</HEAD>

<BODY LANG="EN" BGCOLOR="#FFFFFF" TEXT="#000000" LINK="#0000FF" VLINK="#800080" ALINK="#FF0000">

<A NAME="SEC103"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_11.html#SEC102"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC104"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_11.html#SEC95"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H1> 11. Associations </H1>
<!--docid::SEC103::-->
<P>

MIT Scheme provides several mechanisms for associating objects with
one another.  Each of these mechanisms creates a link between one or
more objects, called <EM>keys</EM>, and some other object, called a
<EM>datum</EM>.  Beyond this common idea, however, each of the mechanisms
has various different properties that make it appropriate in different
situations:
</P><P>

<UL>
<LI>
<EM>Association lists</EM> are one of Lisp's oldest association mechanisms.
Because they are made from ordinary pairs, they are easy to build and
manipulate, and very flexible in use.  However, the average lookup time
for an association list is linear in the number of associations.
<P>

<LI>
<EM>1D tables</EM> have a very simple interface, making them easy to use,
and offer the feature that they do not prevent their keys from being
reclaimed by the garbage collector.  Like association lists, their
average lookup time is linear in the number of associations; but 1D
tables aren't as flexible.
<P>

<LI>
<A NAME="IDX1328"></A>
<EM>The association table</EM> is MIT Scheme's equivalent to the
<EM>property lists</EM> of Lisp.  It has the advantages that the keys may
be any type of object and that it does not prevent the keys from being
reclaimed by the garbage collector.  However, two linear-time lookups
must be performed, one for each key, whereas for traditional property
lists only one lookup is required for both keys.
<P>

<LI>
<EM>Hash tables</EM> are a powerful mechanism with constant-time access to
large amounts of data.  Hash tables are not as flexible as association
lists, but because their access times are independent of the number of
associations in the table, for most applications they are the mechanism
of choice.
<P>

<LI>
<EM>Balanced binary trees</EM> are another association mechanism that is
useful for applications in which the keys are ordered.  Binary trees
have access times that are proportional to the logarithm of the number
of associations in the tree.  While they aren't as fast as hash tables,
they offer the advantage that the contents of the tree can be converted
to a sorted alist in linear time.  Additionally, two trees can be
compared for equality in worst-case linear time.
<P>

<LI>
<EM>Red-Black trees</EM> are a kind of balanced binary tree.  The
implementation supports destructive insertion and deletion operations
with a good constant factor.
<P>

<LI>
<EM>Weight-Balanced trees</EM> are a kind of balanced binary tree.  The
implementation provides non-destructive operations.  There is a
comprehensive set of operations, including: a constant-time size
operation; many high-level operations such as the set operations union,
intersection and difference; and indexing of elements by position.
<P>

</UL>
<P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC104">11.1 Association Lists</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC105">11.2 1D Tables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC106">11.3 The Association Table</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC107">11.4 Hash Tables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC113">11.5 Object Hashing</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC114">11.6 Red-Black Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC115">11.7 Weight-Balanced Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Association Lists"></A>
<HR SIZE="6">
<A NAME="SEC104"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC105"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.1 Association Lists </H2>
<!--docid::SEC104::-->
<P>

<A NAME="IDX1329"></A>
<A NAME="IDX1330"></A>
<A NAME="IDX1331"></A>
<A NAME="IDX1332"></A>
An <EM>association list</EM>, or <EM>alist</EM>, is a data structure used very
frequently in Scheme.  An alist is a list of pairs, each of which is
called an <EM>association</EM>.  The car of an association is called the
<EM>key</EM>.
</P><P>

An advantage of the alist representation is that an alist can be
incrementally augmented simply by adding new entries to the front.
Moreover, because the searching procedures <CODE>assv</CODE> et al. search the
alist in order, new entries can "shadow" old entries.  If an alist is
viewed as a mapping from keys to data, then the mapping can be not only
augmented but also altered in a non-destructive manner by adding new
entries to the front of the alist.<A NAME="DOCF13" HREF="scheme_fot.html#FOOT13">(13)</A>
</P><P>

<A NAME="IDX1333"></A>
<DL>
<DT><U>procedure+:</U> <B>alist?</B> <I>object</I>
<DD><A NAME="IDX1334"></A>
<A NAME="IDX1335"></A>
Returns <CODE>#t</CODE> if <VAR>object</VAR> is an association list (including the
empty list); otherwise returns <CODE>#f</CODE>.  Any <VAR>object</VAR> satisfying this
predicate also satisfies <CODE>list?</CODE>.
</DL>
</P><P>

<A NAME="IDX1336"></A>
<DL>
<DT><U>procedure:</U> <B>assq</B> <I>object alist</I>
<DD><A NAME="IDX1337"></A>
<DT><U>procedure:</U> <B>assv</B> <I>object alist</I>
<DD><A NAME="IDX1338"></A>
<DT><U>procedure:</U> <B>assoc</B> <I>object alist</I>
<DD><A NAME="IDX1339"></A>
<A NAME="IDX1340"></A>
<A NAME="IDX1341"></A>
<A NAME="IDX1342"></A>
These procedures find the first pair in <VAR>alist</VAR> whose car field is
<VAR>object</VAR>, and return that pair; the returned pair is always an
<EM>element</EM> of <VAR>alist</VAR>, <EM>not</EM> one of the pairs from which
<VAR>alist</VAR> is composed.  If no pair in <VAR>alist</VAR> has <VAR>object</VAR> as
its car, <CODE>#f</CODE> (n.b.: not the empty list) is returned.  <CODE>assq</CODE>
uses <CODE>eq?</CODE> to compare <VAR>object</VAR> with the car fields of the pairs
in <VAR>alist</VAR>, while <CODE>assv</CODE> uses <CODE>eqv?</CODE> and <CODE>assoc</CODE> uses
<CODE>equal?</CODE>.<A NAME="DOCF14" HREF="scheme_fot.html#FOOT14">(14)</A>
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                             =>  (a 1)
(assq 'b e)                             =>  (b 2)
(assq 'd e)                             =>  #f
(assq (list 'a) '(((a)) ((b)) ((c))))   =>  #f
(assoc (list 'a) '(((a)) ((b)) ((c))))  =>  ((a))
(assq 5 '((2 3) (5 7) (11 13)))         =>  unspecified
(assv 5 '((2 3) (5 7) (11 13)))         =>  (5 7)
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1343"></A>
<DL>
<DT><U>procedure+:</U> <B>association-procedure</B> <I>predicate selector</I>
<DD>Returns an association procedure that is similar to <CODE>assv</CODE>, except
that <VAR>selector</VAR> (a procedure of one argument) is used to select the
key from the association, and <VAR>predicate</VAR> (an equivalence predicate)
is used to compare the key to the given item.  This can be used to make
association lists whose elements are, say, vectors instead of pairs
(also see section <A HREF="scheme_8.html#SEC79">7.6 Searching Lists</A>).
</P><P>

For example, here is how <CODE>assv</CODE> could be implemented:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define assv (association-procedure eqv? car))
</pre></td></tr></table></P><P>

Another example is a "reverse association" procedure:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define rassv (association-procedure eqv? cdr))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1344"></A>
<DL>
<DT><U>procedure+:</U> <B>del-assq</B> <I>object alist</I>
<DD><A NAME="IDX1345"></A>
<DT><U>procedure+:</U> <B>del-assv</B> <I>object alist</I>
<DD><A NAME="IDX1346"></A>
<DT><U>procedure+:</U> <B>del-assoc</B> <I>object alist</I>
<DD><A NAME="IDX1347"></A>
<A NAME="IDX1348"></A>
<A NAME="IDX1349"></A>
<A NAME="IDX1350"></A>
These procedures return a newly allocated copy of <VAR>alist</VAR> in which
all associations with keys equal to <VAR>object</VAR> have been removed.
Note that while the returned copy is a newly allocated list, the
association pairs that are the elements of the list are shared with
<VAR>alist</VAR>, not copied.  <CODE>del-assq</CODE> uses <CODE>eq?</CODE> to compare
<VAR>object</VAR> with the keys, while <CODE>del-assv</CODE> uses <CODE>eqv?</CODE> and
<CODE>del-assoc</CODE> uses <CODE>equal?</CODE>.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define a
  '((butcher . "231 e22nd St.")
    (baker . "515 w23rd St.")
    (hardware . "988 Lexington Ave.")))

(del-assq 'baker a)
     =>
     ((butcher . "231 e22nd St.")
      (hardware . "988 Lexington Ave."))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1351"></A>
<DL>
<DT><U>procedure+:</U> <B>del-assq!</B> <I>object alist</I>
<DD><A NAME="IDX1352"></A>
<DT><U>procedure+:</U> <B>del-assv!</B> <I>object alist</I>
<DD><A NAME="IDX1353"></A>
<DT><U>procedure+:</U> <B>del-assoc!</B> <I>object alist</I>
<DD><A NAME="IDX1354"></A>
<A NAME="IDX1355"></A>
<A NAME="IDX1356"></A>
These procedures remove from <VAR>alist</VAR> all associations with keys
equal to <VAR>object</VAR>.  They return the resulting list.
<CODE>del-assq!</CODE> uses <CODE>eq?</CODE> to compare <VAR>object</VAR> with the keys,
while <CODE>del-assv!</CODE> uses <CODE>eqv?</CODE> and <CODE>del-assoc!</CODE> uses
<CODE>equal?</CODE>.  These procedures are like <CODE>del-assq</CODE>,
<CODE>del-assv</CODE>, and <CODE>del-assoc</CODE>, respectively, except that they
destructively modify <VAR>alist</VAR>.
</DL>
</P><P>

<A NAME="IDX1357"></A>
<DL>
<DT><U>procedure+:</U> <B>delete-association-procedure</B> <I>deletor predicate selector</I>
<DD><A NAME="IDX1358"></A>
<A NAME="IDX1359"></A>
This returns a deletion procedure similar to <CODE>del-assv</CODE> or
<CODE>del-assq!</CODE>.  The <VAR>predicate</VAR> and <VAR>selector</VAR> arguments are
the same as those for <CODE>association-procedure</CODE>, while the
<VAR>deletor</VAR> argument should be either the procedure
<CODE>list-deletor</CODE> (for non-destructive deletions), or the procedure
<CODE>list-deletor!</CODE> (for destructive deletions).
</P><P>

For example, here is a possible implementation of <CODE>del-assv</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define del-assv 
  (delete-association-procedure list-deletor eqv? car))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1360"></A>
<DL>
<DT><U>procedure+:</U> <B>alist-copy</B> <I>alist</I>
<DD><A NAME="IDX1361"></A>
<A NAME="IDX1362"></A>
Returns a newly allocated copy of <VAR>alist</VAR>.  This is similar to
<CODE>list-copy</CODE> except that the "association" pairs, i.e. the
elements of the list <VAR>alist</VAR>, are also copied.  <CODE>alist-copy</CODE>
could have been implemented like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (alist-copy alist)
  (if (null? alist)
      '()
      (cons (cons (car (car alist)) (cdr (car alist)))
            (alist-copy (cdr alist)))))
</pre></td></tr></table></DL>
</P><P>

<A NAME="1D Tables"></A>
<HR SIZE="6">
<A NAME="SEC105"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC104"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.2 1D Tables </H2>
<!--docid::SEC105::-->
<P>

<A NAME="IDX1363"></A>
<A NAME="IDX1364"></A>
<A NAME="IDX1365"></A>
<A NAME="IDX1366"></A>
<EM>1D tables</EM> ("one-dimensional" tables) are similar to association
lists.  In a 1D table, unlike an association list, the keys of the table
are held <EM>weakly</EM>: if a key is garbage-collected, its associated
value in the table is removed.  1D tables compare their keys for
equality using <CODE>eq?</CODE>.
</P><P>

<A NAME="IDX1367"></A>
1D tables can often be used as a higher-performance alternative to the
two-dimensional association table (see section <A HREF="scheme_12.html#SEC106">11.3 The Association Table</A>).  If
one of the keys being associated is a compound object such as a vector,
a 1D table can be stored in one of the vector's slots.  Under these
circumstances, accessing items in a 1D table will be comparable in
performance to using a property list in a conventional Lisp.
</P><P>

<A NAME="IDX1368"></A>
<DL>
<DT><U>procedure+:</U> <B>make-1d-table</B>
<DD>Returns a newly allocated empty 1D table.
</DL>
</P><P>

<A NAME="IDX1369"></A>
<DL>
<DT><U>procedure+:</U> <B>1d-table?</B> <I>object</I>
<DD><A NAME="IDX1370"></A>
<A NAME="IDX1371"></A>
Returns <CODE>#t</CODE> if <VAR>object</VAR> is a 1D table, otherwise returns
<CODE>#f</CODE>.  Any object that satisfies this predicate also satisfies
<CODE>list?</CODE>.
</DL>
</P><P>

<A NAME="IDX1372"></A>
<DL>
<DT><U>procedure+:</U> <B>1d-table/put!</B> <I>1d-table key datum</I>
<DD>Creates an association between <VAR>key</VAR> and <VAR>datum</VAR> in
<VAR>1d-table</VAR>.  Returns an unspecified value.
</DL>
</P><P>

<A NAME="IDX1373"></A>
<DL>
<DT><U>procedure+:</U> <B>1d-table/remove!</B> <I>1d-table key</I>
<DD>Removes any association for <VAR>key</VAR> in <VAR>1d-table</VAR> and returns an
unspecified value.
</DL>
</P><P>

<A NAME="IDX1374"></A>
<DL>
<DT><U>procedure+:</U> <B>1d-table/get</B> <I>1d-table key default</I>
<DD>Returns the <VAR>datum</VAR> associated with <VAR>key</VAR> in <VAR>1d-table</VAR>.  If
there is no association for <VAR>key</VAR>, <VAR>default</VAR> is returned.
</DL>
</P><P>

<A NAME="IDX1375"></A>
<DL>
<DT><U>procedure+:</U> <B>1d-table/lookup</B> <I>1d-table key if-found if-not-found</I>
<DD><VAR>If-found</VAR> must be a procedure of one argument, and
<VAR>if-not-found</VAR> must be a procedure of no arguments.  If
<VAR>1d-table</VAR> contains an association for <VAR>key</VAR>, <VAR>if-found</VAR> is
invoked on the <VAR>datum</VAR> of the association.  Otherwise,
<VAR>if-not-found</VAR> is invoked with no arguments.  In either case, the
result of the invoked procedure is returned as the result of
<CODE>1d-table/lookup</CODE>.
</DL>
</P><P>

<A NAME="IDX1376"></A>
<DL>
<DT><U>procedure+:</U> <B>1d-table/alist</B> <I>1d-table</I>
<DD>Returns a newly allocated association list that contains the same
information as <VAR>1d-table</VAR>.
</DL>
</P><P>

<A NAME="The Association Table"></A>
<HR SIZE="6">
<A NAME="SEC106"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC105"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.3 The Association Table </H2>
<!--docid::SEC106::-->
<P>

<A NAME="IDX1377"></A>
<A NAME="IDX1378"></A>
<A NAME="IDX1379"></A>
<A NAME="IDX1380"></A>
MIT Scheme provides a generalization of the property-list mechanism
found in most other implementations of Lisp: a global two-dimensional
<EM>association table</EM>.  This table is indexed by two keys, called
<VAR>x-key</VAR> and <VAR>y-key</VAR> in the following procedure descriptions.
These keys and the datum associated with them can be arbitrary objects.
<CODE>eq?</CODE> is used to discriminate keys.
</P><P>

Think of the association table as a matrix: a single datum can be
accessed using both keys, a column using <VAR>x-key</VAR> only, and a row
using <VAR>y-key</VAR> only.
</P><P>

<A NAME="IDX1381"></A>
<DL>
<DT><U>procedure+:</U> <B>2d-put!</B> <I>x-key y-key datum</I>
<DD>Makes an entry in the association table that associates <VAR>datum</VAR> with
<VAR>x-key</VAR> and <VAR>y-key</VAR>.  Returns an unspecified result.
</DL>
</P><P>

<A NAME="IDX1382"></A>
<DL>
<DT><U>procedure+:</U> <B>2d-remove!</B> <I>x-key y-key</I>
<DD>If the association table has an entry for <VAR>x-key</VAR> and <VAR>y-key</VAR>,
it is removed.  Returns an unspecified result.
</DL>
</P><P>

<A NAME="IDX1383"></A>
<DL>
<DT><U>procedure+:</U> <B>2d-get</B> <I>x-key y-key</I>
<DD>Returns the <VAR>datum</VAR> associated with <VAR>x-key</VAR> and <VAR>y-key</VAR>.
Returns <CODE>#f</CODE> if no such association exists.
</DL>
</P><P>

<A NAME="IDX1384"></A>
<DL>
<DT><U>procedure+:</U> <B>2d-get-alist-x</B> <I>x-key</I>
<DD>Returns an association list of all entries in the association table that
are associated with <VAR>x-key</VAR>.  The result is a list of
<CODE>(<VAR>y-key</VAR> . <VAR>datum</VAR>)</CODE> pairs.  Returns the empty list if no
entries for <VAR>x-key</VAR> exist.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(2d-put! 'foo 'bar 5)
(2d-put! 'foo 'baz 6)
(2d-get-alist-x 'foo)           =>  ((baz . 6) (bar . 5))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1385"></A>
<DL>
<DT><U>procedure+:</U> <B>2d-get-alist-y</B> <I>y-key</I>
<DD>Returns an association list of all entries in the association table that
are associated with <VAR>y-key</VAR>.  The result is a list of
<CODE>(<VAR>x-key</VAR> . <VAR>datum</VAR>)</CODE> pairs.  Returns the empty list if no
entries for <VAR>y-key</VAR> exist.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(2d-put! 'bar 'foo 5)
(2d-put! 'baz 'foo 6)
(2d-get-alist-y 'foo)           =>  ((baz . 6) (bar . 5))
</pre></td></tr></table></DL>
</P><P>

<A NAME="Hash Tables"></A>
<HR SIZE="6">
<A NAME="SEC107"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC108"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.4 Hash Tables </H2>
<!--docid::SEC107::-->
<P>

<A NAME="IDX1386"></A>
Hash tables are a fast, powerful mechanism for storing large numbers of
associations.  MIT Scheme's hash tables feature automatic resizing,
customizable growth parameters, and customizable hash procedures.
</P><P>

The average times for the insertion, deletion, and lookup operations on
a hash table are bounded by a constant.  The space required by the table
is proportional to the number of associations in the table; the
constant of proportionality is described below (see section <A HREF="scheme_12.html#SEC110">11.4.3 Resizing of Hash Tables</A>).
</P><P>

<A NAME="IDX1387"></A>
<A NAME="IDX1388"></A>
The hash-table implementation is a run-time-loadable option.  To use
hash tables, execute
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(load-option 'hash-table)
</pre></td></tr></table><A NAME="IDX1389"></A>
</P><P>

once before calling any of the procedures defined here.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC108">11.4.1 Construction of Hash Tables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC109">11.4.2 Basic Hash Table Operations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC110">11.4.3 Resizing of Hash Tables</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC111">11.4.4 Address Hashing</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC112">11.4.5 Low-Level Hash Table Operations</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Construction of Hash Tables"></A>
<HR SIZE="6">
<A NAME="SEC108"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC109"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.4.1 Construction of Hash Tables </H3>
<!--docid::SEC108::-->
<P>

<A NAME="IDX1390"></A>
The next few procedures are hash-table constructors.  All hash table
constructors are procedures that accept one optional argument,
<VAR>initial-size</VAR>, and return a newly allocated hash table.  If
<VAR>initial-size</VAR> is given, it must be an exact non-negative integer or
<CODE>#f</CODE>.  The meaning of <VAR>initial-size</VAR> is discussed below
(see section <A HREF="scheme_12.html#SEC110">11.4.3 Resizing of Hash Tables</A>).
</P><P>

<A NAME="IDX1391"></A>
<A NAME="IDX1392"></A>
<A NAME="IDX1393"></A>
Hash tables are normally characterized by two things: the equivalence
predicate that is used to compare keys, and whether or not the table
allows its keys to be reclaimed by the garbage collector.  If a table
prevents its keys from being reclaimed by the garbage collector, it is
said to hold its keys <EM>strongly</EM>; otherwise it holds its keys
<EM>weakly</EM> (see section <A HREF="scheme_11.html#SEC102">10.7 Weak Pairs</A>).
</P><P>

<A NAME="IDX1394"></A>
<DL>
<DT><U>procedure+:</U> <B>make-eq-hash-table</B> <I>[initial-size]</I>
<DD><A NAME="IDX1395"></A>
Returns a newly allocated hash table that accepts arbitrary objects as
keys, and compares those keys with <CODE>eq?</CODE>.  The keys are held
weakly.  These are the fastest of the standard hash tables.
</DL>
</P><P>

<A NAME="IDX1396"></A>
<DL>
<DT><U>procedure+:</U> <B>make-eqv-hash-table</B> <I>[initial-size]</I>
<DD><A NAME="IDX1397"></A>
Returns a newly allocated hash table that accepts arbitrary objects as
keys, and compares those keys with <CODE>eqv?</CODE>.  The keys are held
weakly, except that booleans, characters, and numbers are held strongly.
These hash tables are a little slower than those made by
<CODE>make-eq-hash-table</CODE>.
</DL>
</P><P>

<A NAME="IDX1398"></A>
<DL>
<DT><U>procedure+:</U> <B>make-equal-hash-table</B> <I>[initial-size]</I>
<DD><A NAME="IDX1399"></A>
Returns a newly allocated hash table that accepts arbitrary objects as
keys, and compares those keys with <CODE>equal?</CODE>.  The keys are held
strongly.  These hash tables are quite a bit slower than those made by
<CODE>make-eq-hash-table</CODE>.
</DL>
</P><P>

<A NAME="IDX1400"></A>
<DL>
<DT><U>procedure+:</U> <B>make-string-hash-table</B> <I>[initial-size]</I>
<DD><A NAME="IDX1401"></A>
Returns a newly allocated hash table that accepts character strings as
keys, and compares them with <CODE>string=?</CODE>.  The keys are held
strongly.
</DL>
</P><P>

The next two procedures are used to create new hash-table constructors.
All of the above hash table constructors, with the exception of
<CODE>make-eqv-hash-table</CODE>, could have been created by calls to these
"constructor-constructors"; see the examples below.
</P><P>

<A NAME="IDX1402"></A>
<DL>
<DT><U>procedure+:</U> <B>strong-hash-table/constructor</B> <I>key-hash key=? [rehash-after-gc?]</I>
<DD><A NAME="IDX1403"></A>
<DT><U>procedure+:</U> <B>weak-hash-table/constructor</B> <I>key-hash key=? [rehash-after-gc?]</I>
<DD><A NAME="IDX1404"></A>
<A NAME="IDX1405"></A>
Each of these procedures accepts two arguments and returns a hash-table
constructor.  The <VAR>key=?</VAR> argument is an equivalence predicate for
the keys of the hash table.  The <VAR>key-hash</VAR> argument is a procedure
that computes a hash number.  Specifically, <VAR>key-hash</VAR> accepts two
arguments, a key and an exact positive integer (the <EM>modulus</EM>), and
returns an exact non-negative integer that is less than the modulus.
</P><P>

The optional argument <VAR>rehash-after-gc?</VAR>, if true, says that the
values returned by <VAR>key-hash</VAR> might change after a garbage
collection.  If so, the hash-table implementation arranges for the table
to be rehashed when necessary.  (See section <A HREF="scheme_12.html#SEC111">11.4.4 Address Hashing</A>, for
information about hash procedures that have this property.)  Otherwise,
it is assumed that <VAR>key-hash</VAR> always returns the same value for the
same arguments.  The default value of this argument is <CODE>#f</CODE>.
</P><P>

The constructors returned by <CODE>strong-hash-table/constructor</CODE> make
hash tables that hold their keys strongly.  The constructors returned by
<CODE>weak-hash-table/constructor</CODE> make hash tables that hold their keys
weakly.
</DL>
</P><P>

Some examples showing how some standard hash-table constructors could have
been defined:
</P><P>

<A NAME="IDX1406"></A>
<A NAME="IDX1407"></A>
<A NAME="IDX1408"></A>
<A NAME="IDX1409"></A>
<A NAME="IDX1410"></A>
<A NAME="IDX1411"></A>
<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define make-eq-hash-table
  (weak-hash-table/constructor eq-hash-mod eq? #t))

(define make-equal-hash-table
  (strong-hash-table/constructor equal-hash-mod equal? #t))

(define make-string-hash-table
  (strong-hash-table/constructor string-hash-mod string=? #f))
</pre></td></tr></table></P><P>

The following procedure is sometimes useful in conjunction with weak
hash tables.  Normally it is not needed, because such hash tables clean
themselves automatically as they are used.
</P><P>

<A NAME="IDX1412"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/clean!</B> <I>hash-table</I>
<DD>If <VAR>hash-table</VAR> is a type of hash table that holds its <VAR>key</VAR>s
weakly, this procedure recovers any space that was being used to record
associations for objects that have been reclaimed by the garbage
collector.  Otherwise, this procedure does nothing.  In either case, it
returns an unspecified result.
</DL>
</P><P>

<A NAME="Basic Hash Table Operations"></A>
<HR SIZE="6">
<A NAME="SEC109"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC108"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC110"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.4.2 Basic Hash Table Operations </H3>
<!--docid::SEC109::-->
<P>

The procedures described in this section are the basic operations on
hash tables.  They provide the functionality most often needed by
programmers.  Subsequent sections describe other operations that provide
additional functionality needed by some applications.
</P><P>

<A NAME="IDX1413"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table?</B> <I>object</I>
<DD><A NAME="IDX1414"></A>
Returns <CODE>#t</CODE> if <VAR>object</VAR> is a hash table, otherwise returns
<CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1415"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/put!</B> <I>hash-table key datum</I>
<DD>Associates <VAR>datum</VAR> with <VAR>key</VAR> in <VAR>hash-table</VAR> and returns an
unspecified result.  The average time required by this operation is
bounded by a constant.
</DL>
</P><P>

<A NAME="IDX1416"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/get</B> <I>hash-table key default</I>
<DD>Returns the datum associated with <VAR>key</VAR> in <VAR>hash-table</VAR>.  If
there is no association for <VAR>key</VAR>, <VAR>default</VAR> is returned.  The
average time required by this operation is bounded by a constant.
</DL>
</P><P>

<A NAME="IDX1417"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/remove!</B> <I>hash-table key</I>
<DD>If <VAR>hash-table</VAR> has an association for <VAR>key</VAR>, removes it.
Returns an unspecified result.  The average time required by this
operation is bounded by a constant.
</DL>
</P><P>

<A NAME="IDX1418"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/clear!</B> <I>hash-table</I>
<DD>Removes all associations in <VAR>hash-table</VAR> and returns an unspecified
result.  The average and worst-case times required by this operation are
bounded by a constant.
</DL>
</P><P>

<A NAME="IDX1419"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/count</B> <I>hash-table</I>
<DD>Returns the number of associations in <VAR>hash-table</VAR> as an exact
non-negative integer.  If <VAR>hash-table</VAR> holds its keys weakly, this
is a conservative upper bound that may count some associations whose
keys have recently been reclaimed by the garbage collector.  The average
and worst-case times required by this operation are bounded by a
constant.
</DL>
</P><P>

<A NAME="IDX1420"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table-&#62;alist</B> <I>hash-table</I>
<DD>Returns the contents of <VAR>hash-table</VAR> as a newly allocated alist.
Each element of the alist is a pair <CODE>(<VAR>key</VAR> . <VAR>datum</VAR>)</CODE>
where <VAR>key</VAR> is one of the keys of <VAR>hash-table</VAR>, and <VAR>datum</VAR>
is its associated datum.  The average and worst-case times required by
this operation are linear in the number of associations
in the table.
</DL>
</P><P>

<A NAME="IDX1421"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/key-list</B> <I>hash-table</I>
<DD>Returns a newly allocated list of the keys in <VAR>hash-table</VAR>.  The
average and worst-case times required by this operation are linear in
the number of associations in the table.
</DL>
</P><P>

<A NAME="IDX1422"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/datum-list</B> <I>hash-table</I>
<DD>Returns a newly allocated list of the datums in <VAR>hash-table</VAR>.  Each
element of the list corresponds to one of the associations in
<VAR>hash-table</VAR>; if the table contains multiple associations with the
same datum, so will this list.  The average and worst-case times
required by this operation are linear in the number of associations in
the table.
</DL>
</P><P>

<A NAME="IDX1423"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/for-each</B> <I>hash-table procedure</I>
<DD><VAR>Procedure</VAR> must be a procedure of two arguments.  Invokes
<VAR>procedure</VAR> once for each association in <VAR>hash-table</VAR>, passing
the association's <VAR>key</VAR> and <VAR>datum</VAR> as arguments, in that order.
Returns an unspecified result.  <VAR>Procedure</VAR> must not modify
<VAR>hash-table</VAR>, with one exception: it is permitted to call
<CODE>hash-table/remove!</CODE> to remove the association being processed.
</DL>
</P><P>

The following procedure is an alternate form of <CODE>hash-table/get</CODE>
that is useful in some situations.  Usually, <CODE>hash-table/get</CODE> is
preferable because it is faster.
</P><P>

<A NAME="IDX1424"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/lookup</B> <I>hash-table key if-found if-not-found</I>
<DD><VAR>If-found</VAR> must be a procedure of one argument, and
<VAR>if-not-found</VAR> must be a procedure of no arguments.  If
<VAR>hash-table</VAR> contains an association for <VAR>key</VAR>, <VAR>if-found</VAR>
is invoked on the datum of the association.  Otherwise,
<VAR>if-not-found</VAR> is invoked with no arguments.  In either case, the
result yielded by the invoked procedure is returned as the result of
<CODE>hash-table/lookup</CODE> (<CODE>hash-table/lookup</CODE> <EM>reduces</EM> into
the invoked procedure, i.e. calls it tail-recursively).  The average
time required by this operation is bounded by a constant.
</DL>
</P><P>

<A NAME="Resizing of Hash Tables"></A>
<HR SIZE="6">
<A NAME="SEC110"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC109"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC111"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.4.3 Resizing of Hash Tables </H3>
<!--docid::SEC110::-->
<P>

<A NAME="IDX1425"></A>
<A NAME="IDX1426"></A>
Normally, hash tables automatically resize themselves according to need.
Because of this, the programmer need not be concerned with management of
the table's size.  However, some limited control over the table's size
is provided, which will be discussed below.  This discussion involves
two concepts, <EM>usable size</EM> and <EM>physical size</EM>, which we will
now define.
</P><P>

<A NAME="IDX1427"></A>
The <EM>usable size</EM> of a hash table is the number of associations that
the table can hold at a given time.  If the number of associations in
the table exceeds the usable size, the table will automatically grow,
increasing the usable size to a new value that is sufficient to hold the
associations.
</P><P>

<A NAME="IDX1428"></A>
The <EM>physical size</EM> is an abstract measure of a hash table that
specifies how much space is allocated to hold the associations of the
table.  The physical size is always greater than or equal to the usable
size.  The physical size is not interesting in itself; it is interesting
only for its effect on the performance of the hash table.  While the
average performance of a hash-table lookup is bounded by a constant, the
worst-case performance is not.  For a table containing a given number of
associations, increasing the physical size of the table decreases the
probability that worse-than-average performance will occur.
</P><P>

The physical size of a hash table is statistically related to the number
of associations.  However, it is possible to place bounds on the
physical size, and from this to estimate the amount of space used by the
table:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (hash-table-space-bounds count rehash-size rehash-threshold)
  (let ((tf (/ 1 rehash-threshold)))
    (values (if (exact-integer? rehash-size)
                (- (* count (+ 4 tf))
                   (* tf (+ rehash-size rehash-size)))
                (* count (+ 4 (/ tf (* rehash-size rehash-size)))))
            (* count (+ 4 tf)))))
</pre></td></tr></table></P><P>

What this formula shows is that, for a "normal" rehash size (that is,
not an exact integer), the amount of space used by the hash table is
proportional to the number of associations in the table.  The constant
of proportionality varies statistically, with the low bound being
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(+ 4 (/ (/ 1 rehash-threshold) (* rehash-size rehash-size)))
</pre></td></tr></table></P><P>

and the high bound being
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(+ 4 (/ 1 rehash-threshold))
</pre></td></tr></table></P><P>

which, for the default values of these parameters, are <CODE>4.25</CODE> and
<CODE>5</CODE>, respectively.  Reducing the rehash size will tighten these
bounds, but increases the amount of time spent resizing, so you can see
that the rehash size gives some control over the time-space tradeoff of
the table.
</P><P>

The programmer can control the size of a hash table by means of three
parameters:
</P><P>

<UL>
<LI>
Each table's <VAR>initial-size</VAR> may be specified when the table is
created.
<P>

<LI>
Each table has a <EM>rehash size</EM> that specifies how the size of the
table is changed when it is necessary to grow or shrink the table.
<P>

<LI>
Each table has a <EM>rehash threshold</EM> that specifies the relationship
of the table's physical size to its usable size.
</UL>
<P>

<A NAME="IDX1429"></A>
If the programmer knows that the table will initially contain a specific
number of items, <VAR>initial-size</VAR> can be given when the table is
created.  If <VAR>initial-size</VAR> is an exact non-negative integer, it
specifies the initial usable size of the hash table; the table will not
change size until the number of items in the table exceeds
<VAR>initial-size</VAR>, after which automatic resizing is enabled and
<VAR>initial-size</VAR> no longer has any effect.  Otherwise, if
<VAR>initial-size</VAR> is not given or is <CODE>#f</CODE>, the table is
initialized to an unspecified size and automatic resizing is immediately
enabled.
</P><P>

<A NAME="IDX1430"></A>
The <EM>rehash size</EM> specifies how much to increase the usable size of
the hash table when it becomes full.  It is either an exact positive
integer, or a real number greater than one.  If it is an integer, the
new size is the sum of the old size and the rehash size.  Otherwise, it
is a real number, and the new size is the product of the old size and
the rehash size.  Increasing the rehash size decreases the average cost
of an insertion, but increases the average amount of space used by the
table.  The rehash size of a table may be altered dynamically by the
application in order to optimize the resizing of the table; for example,
if the table will grow quickly for a known period and afterwards will
not change size, performance might be improved by using a large rehash
size during the growth phase and a small one during the static phase.
The default rehash size of a newly constructed hash table is <CODE>2.0</CODE>.
</P><P>

<STRONG>Warning</STRONG>: The use of an exact positive integer for a rehash
size is almost always undesirable; this option is provided solely for
compatibility with the Common Lisp hash-table mechanism.  The reason for
this has to do with the time penalty for resizing the hash table.  The
time needed to resize a hash table is proportional to the
number of associations in the table.  This resizing cost is
<EM>amortized</EM> across the insertions required to fill the table to the
point where it needs to grow again.  If the table grows by an amount
proportional to the number of associations, then the cost of
resizing and the increase in size are both proportional to the
number of associations, so the <EM>amortized cost</EM> of an insertion
operation is still bounded by a constant.  However, if the table grows
by a constant amount, this is not true: the amortized cost of an
insertion is not bounded by a constant.  Thus, using a constant rehash
size means that the average cost of an insertion increases
proportionally to the number of associations in the hash table.
</P><P>

<A NAME="IDX1431"></A>
The <EM>rehash threshold</EM> is a real number, between zero exclusive and
one inclusive, that specifies the ratio between a hash table's usable
size and its physical size.  Decreasing the rehash threshold decreases
the probability of worse-than-average insertion, deletion, and lookup
times, but increases the physical size of the table for a given usable
size.  The default rehash threshold of a newly constructed hash table is
<CODE>1</CODE>.
</P><P>

<A NAME="IDX1432"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/size</B> <I>hash-table</I>
<DD>Returns the usable size of <VAR>hash-table</VAR> as an exact positive
integer.  This is the number of associations that <VAR>hash-table</VAR> can
hold before it will grow.
</DL>
</P><P>

<A NAME="IDX1433"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/rehash-size</B> <I>hash-table</I>
<DD>Returns the rehash size of <VAR>hash-table</VAR>.
</DL>
</P><P>

<A NAME="IDX1434"></A>
<DL>
<DT><U>procedure+:</U> <B>set-hash-table/rehash-size!</B> <I>hash-table x</I>
<DD><VAR>X</VAR> must be either an exact positive integer, or a real number that
is greater than one.  Sets the rehash size of <VAR>hash-table</VAR> to
<VAR>x</VAR> and returns an unspecified result.  This operation adjusts the
"shrink threshold" of the table; the table might shrink if the number
of associations is less than the new threshold.
</DL>
</P><P>

<A NAME="IDX1435"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/rehash-threshold</B> <I>hash-table</I>
<DD>Returns the rehash threshold of <VAR>hash-table</VAR>.
</DL>
</P><P>

<A NAME="IDX1436"></A>
<DL>
<DT><U>procedure+:</U> <B>set-hash-table/rehash-threshold!</B> <I>hash-table x</I>
<DD><VAR>X</VAR> must be a real number between zero exclusive and one inclusive.
Sets the rehash threshold of <VAR>hash-table</VAR> to <VAR>x</VAR> and returns an
unspecified result.  This operation does not change the usable size of
the table, but it usually changes the physical size of the table, which
causes the table to be rehashed.
</DL>
</P><P>

<A NAME="Address Hashing"></A>
<HR SIZE="6">
<A NAME="SEC111"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC110"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC112"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.4.4 Address Hashing </H3>
<!--docid::SEC111::-->
<P>

The procedures described in this section may be used to make very
efficient key-hashing procedures for arbitrary objects.  All of these
procedures are based on <EM>address hashing</EM>, which uses the address of
an object as its hash number.  The great advantage of address hashing is
that converting an arbitrary object to a hash number is extremely fast
and takes the same amount of time for any object.
</P><P>

The disadvantage of address hashing is that the garbage collector
changes the addresses of most objects.  The hash-table implementation
compensates for this disadvantage by automatically rehashing tables that
use address hashing when garbage collections occur.  Thus, in order to
use these procedures for key hashing, it is necessary to tell the
hash-table implementation (by means of the <VAR>rehash-after-gc?</VAR>
argument to the "constructor-constructor" procedure) that the hash
numbers computed by your key-hashing procedure must be recomputed after
a garbage collection.
</P><P>

<A NAME="IDX1437"></A>
<DL>
<DT><U>procedure+:</U> <B>eq-hash</B> <I>object</I>
<DD><A NAME="IDX1438"></A>
<DT><U>procedure+:</U> <B>eqv-hash</B> <I>object</I>
<DD><A NAME="IDX1439"></A>
<DT><U>procedure+:</U> <B>equal-hash</B> <I>object</I>
<DD>These procedures return a hash number for <VAR>object</VAR>.  The result is
always a non-negative integer, and in the case of <CODE>eq-hash</CODE>, a
non-negative fixnum.  Two objects that are equivalent according to
<CODE>eq?</CODE>, <CODE>eqv?</CODE>, or <CODE>equal?</CODE>, respectively, will produce the
same hash number when passed as arguments to these procedures, provided
that the garbage collector does not run during or between the two calls.
</DL>
</P><P>

The following procedures are the key-hashing procedures used by the
standard address-hash-based hash tables.
</P><P>

<A NAME="IDX1440"></A>
<DL>
<DT><U>procedure+:</U> <B>eq-hash-mod</B> <I>object modulus</I>
<DD>This procedure is the key-hashing procedure used by
<CODE>make-eq-hash-table</CODE>.
</DL>
</P><P>

<A NAME="IDX1441"></A>
<DL>
<DT><U>procedure+:</U> <B>eqv-hash-mod</B> <I>object modulus</I>
<DD>This procedure is the key-hashing procedure used by
<CODE>make-eqv-hash-table</CODE>.
</DL>
</P><P>

<A NAME="IDX1442"></A>
<DL>
<DT><U>procedure+:</U> <B>equal-hash-mod</B> <I>object modulus</I>
<DD>This procedure is the key-hashing procedure used by
<CODE>make-equal-hash-table</CODE>.
</DL>
</P><P>

<A NAME="Low-Level Hash Table Operations"></A>
<HR SIZE="6">
<A NAME="SEC112"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC111"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC106"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.4.5 Low-Level Hash Table Operations </H3>
<!--docid::SEC112::-->
<P>

The procedures in this section allow the programmer to control some of
the internal structure of a hash table.  Normally, hash tables maintain
associations between keys and datums using pairs or weak pairs.  These
procedures allow the programmer to specify the use of some other data
structure to maintain the association.  In this section, the data
structure that represents an association in a hash table is called an
<EM>entry</EM>.
</P><P>

<A NAME="IDX1443"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/constructor</B> <I>key-hash key=? make-entry entry-valid? entry-key entry-datum set-entry-datum! [rehash-after-gc?]</I>
<DD>Creates and returns a hash-table constructor procedure
(see section <A HREF="scheme_12.html#SEC108">11.4.1 Construction of Hash Tables</A>).  The arguments define the
characteristics of the hash table as follows:
</P><P>

<DL COMPACT>
<DT><VAR>key-hash</VAR>
<DD>The hashing procedure.  A procedure that accepts two arguments, a key and
an exact positive integer (the <EM>modulus</EM>), and returns an exact
non-negative integer that is less than the modulus.
<P>

<DT><VAR>key=?</VAR>
<DD>A equivalence predicate that accepts two keys and is true iff they are
the same key.  If this predicate is true of two keys, then
<VAR>key-hash</VAR> must return the same value for each of these keys (given
the same modulus in both cases).
<P>

<DT><VAR>make-entry</VAR>
<DD>A procedure that accepts a key and a datum as arguments and returns a
newly allocated entry.
<P>

<DT><VAR>entry-valid?</VAR>
<DD>A procedure that accepts an entry and returns <CODE>#f</CODE> iff the entry's
key has been reclaimed by the garbage collector.  Instead of a
procedure, this may be <CODE>#t</CODE>, which is equivalent to <CODE>(lambda
(entry) #t)</CODE>.
<A NAME="IDX1444"></A>
<P>

<DT><VAR>entry-key</VAR>
<DD>A procedure that accepts an entry as an argument and returns the entry's
key.
<P>

<DT><VAR>entry-datum</VAR>
<DD>A procedure that accepts an entry as an argument and returns the entry's
datum.
<P>

<DT><VAR>set-entry-datum!</VAR>
<DD>A procedure that accepts an entry and an object as arguments, modifies
the entry's datum to be the object, and returns an unspecified
result.
<P>

<DT><VAR>rehash-after-gc?</VAR>
<DD>An optional argument that, if true, says the values returned by
<VAR>key-hash</VAR> might change after a garbage collection.  If so, the
hash-table implementation arranges for the table to be rehashed when
necessary.  (See section <A HREF="scheme_12.html#SEC111">11.4.4 Address Hashing</A>, for information about hash
procedures that have this property.)  Otherwise, it is assumed that
<VAR>key-hash</VAR> always returns the same value for the same arguments.
The default value of this argument is <CODE>#f</CODE>.
</DL>
</DL>
<P>

For example, here is how the constructors for ordinary hash tables could
be defined:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (strong-hash-table/constructor key-hash key=?
                                       #!optional rehash-after-gc?)
  (hash-table/constructor key-hash key=?
                          cons #t car cdr set-cdr!
                          (if (default-object? rehash-after-gc?)
                              #f
                              rehash-after-gc?)))

(define (weak-hash-table/constructor key-hash key=?
                                     #!optional rehash-after-gc?)
  (hash-table/constructor key-hash key=? weak-cons weak-pair/car?
                          weak-car weak-cdr weak-set-cdr!
                          (if (default-object? rehash-after-gc?)
                              #f
                              rehash-after-gc?)))
</pre></td></tr></table></P><P>

<A NAME="IDX1445"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/key-hash</B> <I>hash-table</I>
<DD><A NAME="IDX1446"></A>
<DT><U>procedure+:</U> <B>hash-table/key=?</B> <I>hash-table</I>
<DD><A NAME="IDX1447"></A>
<DT><U>procedure+:</U> <B>hash-table/make-entry</B> <I>hash-table</I>
<DD><A NAME="IDX1448"></A>
<DT><U>procedure+:</U> <B>hash-table/entry-valid?</B> <I>hash-table</I>
<DD><A NAME="IDX1449"></A>
<DT><U>procedure+:</U> <B>hash-table/entry-key</B> <I>hash-table</I>
<DD><A NAME="IDX1450"></A>
<DT><U>procedure+:</U> <B>hash-table/entry-datum</B> <I>hash-table</I>
<DD><A NAME="IDX1451"></A>
<DT><U>procedure+:</U> <B>hash-table/set-entry-datum!</B> <I>hash-table</I>
<DD>Each procedure returns the value of the corresponding argument that was
used to construct <VAR>hash-table</VAR>.
</DL>
</P><P>

The following procedures return the contents of a hash table as a
collection of entries.  While the data structure holding the entries is
newly allocated, the entries themselves are not copied.  Since hash
table operations can modify these entries, the entries should be copied
if it is desired to keep them while continuing to modify the table.
</P><P>

<A NAME="IDX1452"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/entries-list</B> <I>hash-table</I>
<DD>Returns a newly allocated list of the entries in <VAR>hash-table</VAR>.
</DL>
</P><P>

<A NAME="IDX1453"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/entries-vector</B> <I>hash-table</I>
<DD>Returns a newly allocated vector of the entries in <VAR>hash-table</VAR>.
Equivalent to
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(list-&#62;vector (hash-table/entries-list <VAR>hash-table</VAR>))
</pre></td></tr></table></DL>
</P><P>

<A NAME="Object Hashing"></A>
<HR SIZE="6">
<A NAME="SEC113"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC112"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC107"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.5 Object Hashing </H2>
<!--docid::SEC113::-->
<P>

<A NAME="IDX1454"></A>
<A NAME="IDX1455"></A>
The MIT Scheme object-hashing facility provides a mechanism for
generating a unique hash number for an arbitrary object.  This hash
number, unlike an object's address, is unchanged by garbage collection.
The object-hashing facility is useful in conjunction with hash tables,
but it may be used for other things as well.  In particular, it is used
in the generation of the written representation for many objects
(see section <A HREF="scheme_15.html#SEC137">14.7 Custom Output</A>).
</P><P>

All of these procedures accept an optional argument called <VAR>table</VAR>;
this table contains the object-integer associations.  If given, this
argument must be an object-hash table as constructed by
<CODE>hash-table/make</CODE> (see below).  If not given, a default table is
used.
</P><P>

<A NAME="IDX1456"></A>
<DL>
<DT><U>procedure+:</U> <B>hash</B> <I>object [table]</I>
<DD><A NAME="IDX1457"></A>
<CODE>hash</CODE> associates an exact non-negative integer with <VAR>object</VAR>
and returns that integer.  If <CODE>hash</CODE> was previously called with
<VAR>object</VAR> as its argument, the integer returned is the same as was
returned by the previous call.  <CODE>hash</CODE> guarantees that distinct
objects (in the sense of <CODE>eq?</CODE>) are associated with distinct
integers.
</DL>
</P><P>

<A NAME="IDX1458"></A>
<DL>
<DT><U>procedure+:</U> <B>unhash</B> <I>k [table]</I>
<DD><CODE>unhash</CODE> takes an exact non-negative integer <VAR>k</VAR> and returns
the object associated with that integer.  If there is no object
associated with <VAR>k</VAR>, or if the object previously associated with
<VAR>k</VAR> has been reclaimed by the garbage collector, an error of type
<CODE>condition-type:bad-range-argument</CODE> is signalled.  In other words,
if <CODE>hash</CODE> previously returned <VAR>k</VAR> for some object, and that
object has not been reclaimed, it is the value of the call to
<CODE>unhash</CODE>.
<A NAME="IDX1459"></A>
</DL>
</P><P>

An object that is passed to <CODE>hash</CODE> as an argument is not protected
from being reclaimed by the garbage collector.  If all other references
to that object are eliminated, the object will be reclaimed.
Subsequently calling <CODE>unhash</CODE> with the hash number of the (now
reclaimed) object will signal an error.
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define x (cons 0 0))           =>  unspecified
(hash x)                        =>  77
(eqv? (hash x) (hash x))        =>  #t
(define x 0)                    =>  unspecified
(gc-flip)                       ;force a garbage collection
(unhash 77)                     error-->
</pre></td></tr></table></P><P>

<A NAME="IDX1460"></A>
<DL>
<DT><U>procedure+:</U> <B>object-hashed?</B> <I>object [table]</I>
<DD>This predicate is true if <VAR>object</VAR> has an associated hash number.
Otherwise it is false.
</DL>
</P><P>

<A NAME="IDX1461"></A>
<DL>
<DT><U>procedure+:</U> <B>valid-hash-number?</B> <I>k [table]</I>
<DD>This predicate is true if <VAR>k</VAR> is the hash number associated with
some object.  Otherwise it is false.
</DL>
</P><P>

The following two procedures provide a lower-level interface to the
object-hashing mechanism.
</P><P>

<A NAME="IDX1462"></A>
<DL>
<DT><U>procedure+:</U> <B>object-hash</B> <I>object [table [insert?]]</I>
<DD><A NAME="IDX1463"></A>
<CODE>object-hash</CODE> is like <CODE>hash</CODE>, except that it accepts an
additional optional argument, <VAR>insert?</VAR>.  If <VAR>insert?</VAR> is
supplied and is <CODE>#f</CODE>, <CODE>object-hash</CODE> will return an integer for
<VAR>object</VAR> only if there is already an association in the table;
otherwise, it will return <CODE>#f</CODE>.  If <VAR>insert?</VAR> is not supplied,
or is not <CODE>#f</CODE>, <CODE>object-hash</CODE> always returns an integer,
creating an association in the table if necessary.
</P><P>

<CODE>object-hash</CODE> additionally treats <CODE>#f</CODE> differently than does
<CODE>hash</CODE>.  Calling <CODE>object-hash</CODE> with <CODE>#f</CODE> as its argument
will return an integer that, when passed to <CODE>unhash</CODE>, will signal
an error rather than returning <CODE>#f</CODE>.  Likewise,
<CODE>valid-hash-number?</CODE> will return <CODE>#f</CODE> for this integer.
</DL>
</P><P>

<A NAME="IDX1464"></A>
<DL>
<DT><U>procedure+:</U> <B>object-unhash</B> <I>k [table]</I>
<DD><CODE>object-unhash</CODE> is like <CODE>unhash</CODE>, except that when <VAR>k</VAR> is
not associated with any object or was previously associated with an
object that has been reclaimed, <CODE>object-unhash</CODE> returns <CODE>#f</CODE>.
This means that there is an ambiguity in the value returned by
<CODE>object-unhash</CODE>: if <CODE>#f</CODE> is returned, there is no way to
tell if <VAR>k</VAR> is associated with <CODE>#f</CODE> or is not associated with
any object at all.
</DL>
</P><P>

Finally, this procedure makes new object-hash tables:
</P><P>

<A NAME="IDX1465"></A>
<DL>
<DT><U>procedure+:</U> <B>hash-table/make</B>
<DD>This procedure creates and returns a new, empty object-hash table that
is suitable for use as the optional <VAR>table</VAR> argument to the above
procedures.  The returned table contains no associations.
</DL>
</P><P>

<A NAME="Red-Black Trees"></A>
<HR SIZE="6">
<A NAME="SEC114"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC113"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC115"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.6 Red-Black Trees </H2>
<!--docid::SEC114::-->
<P>

<A NAME="IDX1466"></A>
<A NAME="IDX1467"></A>
<A NAME="IDX1468"></A>
<A NAME="IDX1469"></A>
Balanced binary trees are a useful data structure for maintaining large
sets of associations whose keys are ordered.  While most applications
involving large association sets should use hash tables, some
applications can benefit from the use of binary trees.  Binary trees
have two advantages over hash tables:
</P><P>

<UL>
<LI>
The contents of a binary tree can be converted to an alist, sorted by
key, in time proportional to the number of associations in the
tree.  A hash table can be converted into an unsorted alist in linear
time; sorting it requires additional time.
<P>

<LI>
Two binary trees can be compared for equality in linear time.  Hash
tables, on the other hand, cannot be compared at all; they must be
converted to alists before comparison can be done, and alist comparison
is quadratic unless the alists are sorted.
</UL>
<P>

MIT Scheme provides an implementation of <EM>red-black</EM> trees.  The
red-black tree-balancing algorithm provides generally good performance
because it doesn't try to keep the tree very closely balanced.  At any
given node in the tree, one side of the node can be twice as high as the
other in the worst case.  With typical data the tree will remain fairly
well balanced anyway.
</P><P>

A red-black tree takes space that is proportional to the number of
associations in the tree.  For the current implementation, the constant
of proportionality is eight words per association.
</P><P>

Red-black trees hold their keys <EM>strongly</EM>.  In other words, if a
red-black tree contains an association for a given key, that key cannot
be reclaimed by the garbage collector.
</P><P>

<A NAME="IDX1470"></A>
<A NAME="IDX1471"></A>
The red-black tree implementation is a run-time-loadable option.  To use
red-black trees, execute
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(load-option 'rb-tree)
</pre></td></tr></table><A NAME="IDX1472"></A>
</P><P>

once before calling any of the procedures defined here.
</P><P>

<A NAME="IDX1473"></A>
<DL>
<DT><U>procedure+:</U> <B>make-rb-tree</B> <I>key=? key&#60;?</I>
<DD>This procedure creates and returns a newly allocated red-black tree.
The tree contains no associations.  <VAR>Key=?</VAR> and <VAR>key&#60;?</VAR> are
predicates that compare two keys and determine whether they are equal to
or less than one another, respectively.  For any two keys, at most one
of these predicates is true.
</DL>
</P><P>

<A NAME="IDX1474"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree?</B> <I>object</I>
<DD>Returns <CODE>#t</CODE> if <VAR>object</VAR> is a red-black tree, otherwise
returns <CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1475"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/insert!</B> <I>rb-tree key datum</I>
<DD>Associates <VAR>datum</VAR> with <VAR>key</VAR> in <VAR>rb-tree</VAR> and returns an
unspecified value.  If <VAR>rb-tree</VAR> already has an association for
<VAR>key</VAR>, that association is replaced.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of assocations in <VAR>rb-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1476"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/lookup</B> <I>rb-tree key default</I>
<DD>Returns the datum associated with <VAR>key</VAR> in <VAR>rb-tree</VAR>.  If
<VAR>rb-tree</VAR> doesn't contain an association for <VAR>key</VAR>,
<VAR>default</VAR> is returned.  The average and worst-case times required by
this operation are proportional to the logarithm of the number of
assocations in <VAR>rb-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1477"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/delete!</B> <I>rb-tree key</I>
<DD>If <VAR>rb-tree</VAR> contains an association for <VAR>key</VAR>, removes it.
Returns an unspecified value.  The average and worst-case times required
by this operation are proportional to the logarithm of the number of
assocations in <VAR>rb-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1478"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree-&#62;alist</B> <I>rb-tree</I>
<DD>Returns the contents of <VAR>rb-tree</VAR> as a newly allocated alist.  Each
element of the alist is a pair <CODE>(<VAR>key</VAR> . <VAR>datum</VAR>)</CODE> where
<VAR>key</VAR> is one of the keys of <VAR>rb-tree</VAR>, and <VAR>datum</VAR> is its
associated datum.  The alist is sorted by key according to the
<VAR>key&#60;?</VAR> argument used to construct <VAR>rb-tree</VAR>.  The
time required by this operation is proportional to the
number of associations in the tree.
</DL>
</P><P>

<A NAME="IDX1479"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/key-list</B> <I>rb-tree</I>
<DD>Returns a newly allocated list of the keys in <VAR>rb-tree</VAR>.  The list
is sorted by key according to the <VAR>key&#60;?</VAR> argument used to construct
<VAR>rb-tree</VAR>.  The time required by this
operation is proportional to the number of associations in the tree.
</DL>
</P><P>

<A NAME="IDX1480"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/datum-list</B> <I>rb-tree</I>
<DD>Returns a newly allocated list of the datums in <VAR>rb-tree</VAR>.  Each
element of the list corresponds to one of the associations in
<VAR>rb-tree</VAR>, so if the tree contains multiple associations with the
same datum, so will this list.  The list is sorted by the keys of the
associations, even though they do not appear in the result.  The time required by this operation is proportional to the
number of associations in the tree.
</P><P>

This procedure is equivalent to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (rb-tree) (map cdr (rb-tree-&#62;alist rb-tree)))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1481"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/equal?</B> <I>rb-tree-1 rb-tree-2 datum=?</I>
<DD>Compares <VAR>rb-tree-1</VAR> and <VAR>rb-tree-2</VAR> for equality, returning
<CODE>#t</CODE> iff they are equal and <CODE>#f</CODE> otherwise.  The trees must
have been constructed with the same equality and order predicates (same
in the sense of <CODE>eq?</CODE>).  The keys of the trees are compared using
the <VAR>key=?</VAR> predicate used to build the trees, while the datums of
the trees are compared using the equivalence predicate <VAR>datum=?</VAR>.
The worst-case time required by this operation is proportional to the
number of associations in the tree.
</DL>
</P><P>

<A NAME="IDX1482"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/empty?</B> <I>rb-tree</I>
<DD>Returns <CODE>#t</CODE> iff <VAR>rb-tree</VAR> contains no associations.  Otherwise
returns <CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1483"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/size</B> <I>rb-tree</I>
<DD>Returns the number of associations in <VAR>rb-tree</VAR>, an exact
non-negative integer.  The average and worst-case times required by this
operation are proportional to the number of associations in the tree.
</DL>
</P><P>

<A NAME="IDX1484"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/height</B> <I>rb-tree</I>
<DD>Returns the height of <VAR>rb-tree</VAR>, an exact non-negative integer.
This is the length of the longest path from a leaf of the tree to the
root.  The average and worst-case times required by this operation are
proportional to the number of associations in the tree.
</P><P>

The returned value satisfies the following:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (rb-tree)
  (let ((size (rb-tree/size rb-tree))
        (lg (lambda (x) (/ (log x) (log 2)))))
    (&#60;= (lg size)
        (rb-tree/height rb-tree)
        (* 2 (lg (+ size 1))))))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1485"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/copy</B> <I>rb-tree</I>
<DD>Returns a newly allocated copy of <VAR>rb-tree</VAR>.  The copy is identical
to <VAR>rb-tree</VAR> in all respects, except that changes to <VAR>rb-tree</VAR>
do not affect the copy, and vice versa.  The time required by this
operation is proportional to the number of associations in the tree.
</DL>
</P><P>

<A NAME="IDX1486"></A>
<DL>
<DT><U>procedure+:</U> <B>alist-&#62;rb-tree</B> <I>alist key=? key&#60;?</I>
<DD>Returns a newly allocated red-black tree that contains the same
associations as <VAR>alist</VAR>.  This procedure is equivalent to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (alist key=? key&#60;?)
  (let ((tree (make-rb-tree key=? key&#60;?)))
    (for-each (lambda (association)
                (rb-tree/insert! tree
                                 (car association)
                                 (cdr association)))
              alist)
    tree))
</pre></td></tr></table></DL>
</P><P>

The following operations provide access to the smallest and largest
members in a red/black tree.  They are useful for implementing priority
queues.
</P><P>

<A NAME="IDX1487"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/min</B> <I>rb-tree default</I>
<DD>Returns the smallest key in <VAR>rb-tree</VAR>, or <VAR>default</VAR> if the tree
is empty.
</DL>
</P><P>

<A NAME="IDX1488"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/min-datum</B> <I>rb-tree default</I>
<DD>Returns the datum associated with the smallest key in <VAR>rb-tree</VAR>, or
<VAR>default</VAR> if the tree is empty.
</DL>
</P><P>

<A NAME="IDX1489"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/min-pair</B> <I>rb-tree</I>
<DD>Finds the smallest key in <VAR>rb-tree</VAR> and returns a pair containing
that key and its associated datum.  If the tree is empty, returns
<CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1490"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/max</B> <I>rb-tree default</I>
<DD>Returns the largest key in <VAR>rb-tree</VAR>, or <VAR>default</VAR> if the tree
is empty.
</DL>
</P><P>

<A NAME="IDX1491"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/max-datum</B> <I>rb-tree default</I>
<DD>Returns the datum associated with the largest key in <VAR>rb-tree</VAR>, or
<VAR>default</VAR> if the tree is empty.
</DL>
</P><P>

<A NAME="IDX1492"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/max-pair</B> <I>rb-tree</I>
<DD>Finds the largest key in <VAR>rb-tree</VAR> and returns a pair containing
that key and its associated datum.  If the tree is empty, returns
<CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1493"></A>
<DL>
<DT><U>procedure+:</U> <B>rb-tree/delete-min!</B> <I>rb-tree default</I>
<DD><A NAME="IDX1494"></A>
<DT><U>procedure+:</U> <B>rb-tree/delete-min-datum!</B> <I>rb-tree default</I>
<DD><A NAME="IDX1495"></A>
<DT><U>procedure+:</U> <B>rb-tree/delete-min-pair!</B> <I>rb-tree</I>
<DD><A NAME="IDX1496"></A>
<DT><U>procedure+:</U> <B>rb-tree/delete-max!</B> <I>rb-tree default</I>
<DD><A NAME="IDX1497"></A>
<DT><U>procedure+:</U> <B>rb-tree/delete-max-datum!</B> <I>rb-tree default</I>
<DD><A NAME="IDX1498"></A>
<DT><U>procedure+:</U> <B>rb-tree/delete-max-pair!</B> <I>rb-tree</I>
<DD>These operations are exactly like the accessors above, in that they
return information associated with the smallest or largest key, except
that they simultaneously delete that key.
</DL>
</P><P>

<A NAME="Weight-Balanced Trees"></A>
<HR SIZE="6">
<A NAME="SEC115"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC116"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC103"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H2> 11.7 Weight-Balanced Trees </H2>
<!--docid::SEC115::-->
<P>

<A NAME="IDX1499"></A>
<A NAME="IDX1500"></A>
<A NAME="IDX1501"></A>
<A NAME="IDX1502"></A>
Balanced binary trees are a useful data structure for maintaining large
sets of ordered objects or sets of associations whose keys are ordered.
MIT Scheme has a comprehensive implementation of weight-balanced binary
trees which has several advantages over the other data structures for
large aggregates:
</P><P>

<UL>
<LI>
In addition to the usual element-level operations like insertion,
deletion and lookup, there is a full complement of collection-level
operations, like set intersection, set union and subset test, all of
which are implemented with good orders of growth in time and space.
This makes weight-balanced trees ideal for rapid prototyping of
functionally derived specifications.
<P>

<LI>
An element in a tree may be indexed by its position under the ordering
of the keys, and the ordinal position of an element may be determined,
both with reasonable efficiency.
<P>

<LI>
Operations to find and remove minimum element make weight-balanced trees
simple to use for priority queues.
<P>

<LI>
The implementation is <EM>functional</EM> rather than <EM>imperative</EM>.
This means that operations like `inserting' an association in a tree do
not destroy the old tree, in much the same way that <CODE>(+ 1 x)</CODE>
modifies neither the constant 1 nor the value bound to <CODE>x</CODE>.  The
trees are referentially transparent thus the programmer need not worry
about copying the trees.  Referential transparency allows space
efficiency to be achieved by sharing subtrees.
</UL>
<P>

These features make weight-balanced trees suitable for a wide range of
applications, especially those that require large numbers of sets or
discrete maps.  Applications that have a few global databases and/or
concentrate on element-level operations like insertion and lookup are
probably better off using hash tables or red-black trees.
</P><P>

The <EM>size</EM> of a tree is the number of associations that it
contains.  Weight-balanced binary trees are balanced to keep the sizes
of the subtrees of each node within a constant factor of each other.
This ensures logarithmic times for single-path operations (like lookup
and insertion).  A weight-balanced tree takes space that is proportional
to the number of associations in the tree.  For the current
implementation, the constant of proportionality is six words per
association.
</P><P>

<A NAME="IDX1503"></A>
<A NAME="IDX1504"></A>
<A NAME="IDX1505"></A>
<A NAME="IDX1506"></A>
Weight-balanced trees can be used as an implementation for either
discrete sets or discrete maps (associations).  Sets are implemented by
ignoring the datum that is associated with the key.  Under this scheme
if an association exists in the tree this indicates that the key of the
association is a member of the set.  Typically a value such as
<CODE>()</CODE>, <CODE>#t</CODE> or <CODE>#f</CODE> is associated with the key.
</P><P>

Many operations can be viewed as computing a result that, depending on
whether the tree arguments are thought of as sets or maps, is known by
two different names.  An example is <CODE>wt-tree/member?</CODE>, which, when
regarding the tree argument as a set, computes the set membership
operation, but, when regarding the tree as a discrete map,
<CODE>wt-tree/member?</CODE> is the predicate testing if the map is defined at
an element in its domain.  Most names in this package have been chosen
based on interpreting the trees as sets, hence the name
<CODE>wt-tree/member?</CODE> rather than <CODE>wt-tree/defined-at?</CODE>.
</P><P>

<A NAME="IDX1507"></A>
<A NAME="IDX1508"></A>
The weight-balanced tree implementation is a run-time-loadable option.
To use weight-balanced trees, execute
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(load-option 'wt-tree)
</pre></td></tr></table><A NAME="IDX1509"></A>
</P><P>

once before calling any of the procedures defined here.
</P><P>

<BLOCKQUOTE><TABLE BORDER=0 CELLSPACING=0> 
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC116">11.7.1 Construction of Weight-Balanced Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC117">11.7.2 Basic Operations on Weight-Balanced Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC118">11.7.3 Advanced Operations on Weight-Balanced Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
<TR><TD ALIGN="left" VALIGN="TOP"><A HREF="scheme_12.html#SEC119">11.7.4 Indexing Operations on Weight-Balanced Trees</A></TD><TD>&nbsp;&nbsp;</TD><TD ALIGN="left" VALIGN="TOP"></TD></TR>
</TABLE></BLOCKQUOTE>
<P>

<A NAME="Construction of Weight-Balanced Trees"></A>
<HR SIZE="6">
<A NAME="SEC116"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC115"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC117"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC115"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.7.1 Construction of Weight-Balanced Trees </H3>
<!--docid::SEC116::-->
<P>

Binary trees require there to be a total order on the keys used to
arrange the elements in the tree.  Weight-balanced trees are organized
by <EM>types</EM>, where the type is an object encapsulating the ordering
relation.  Creating a tree is a two-stage process.  First a tree type
must be created from the predicate that gives the ordering.  The tree type
is then used for making trees, either empty or singleton trees or trees
from other aggregate structures like association lists.  Once created, a
tree `knows' its type and the type is used to test compatibility between
trees in operations taking two trees.  Usually a small number of tree
types are created at the beginning of a program and used many times
throughout the program's execution.
</P><P>

<A NAME="IDX1510"></A>
<DL>
<DT><U>procedure+:</U> <B>make-wt-tree-type</B> <I>key&#60;?</I>
<DD>This procedure creates and returns a new tree type based on the ordering
predicate <VAR>key&#60;?</VAR>.
<VAR>Key&#60;?</VAR> must be a total ordering, having the property that for all
key values <CODE>a</CODE>, <CODE>b</CODE> and <CODE>c</CODE>:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(key&#60;? a a)                         => #f
(and (key&#60;? a b) (key&#60;? b a))       => #f
(if (and (key&#60;? a b) (key&#60;? b c))
    (key&#60;? a c)
    #t)                             => #t
</pre></td></tr></table></P><P>

Two key values are assumed to be equal if neither is less than the other
by <VAR>key&#60;?</VAR>.
</P><P>

Each call to <CODE>make-wt-tree-type</CODE> returns a distinct value, and
trees are only compatible if their tree types are <CODE>eq?</CODE>.  A
consequence is that trees that are intended to be used in binary-tree
operations must all be created with a tree type originating from the
same call to <CODE>make-wt-tree-type</CODE>.
</DL>
</P><P>

<A NAME="IDX1511"></A>
<DL>
<DT><U>variable+:</U> <B>number-wt-type</B>
<DD>A standard tree type for trees with numeric keys.  <CODE>Number-wt-type</CODE>
could have been defined by
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define number-wt-type (make-wt-tree-type  &#60;))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1512"></A>
<DL>
<DT><U>variable+:</U> <B>string-wt-type</B>
<DD>A standard tree type for trees with string keys.  <CODE>String-wt-type</CODE>
could have been defined by
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define string-wt-type (make-wt-tree-type  string&#60;?))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1513"></A>
<DL>
<DT><U>procedure+:</U> <B>make-wt-tree</B> <I>wt-tree-type</I>
<DD>This procedure creates and returns a newly allocated weight-balanced
tree.  The tree is empty, i.e. it contains no associations.
<VAR>Wt-tree-type</VAR> is a weight-balanced tree type obtained by calling
<CODE>make-wt-tree-type</CODE>; the returned tree has this type.
</DL>
</P><P>

<A NAME="IDX1514"></A>
<DL>
<DT><U>procedure+:</U> <B>singleton-wt-tree</B> <I>wt-tree-type key datum</I>
<DD>This procedure creates and returns a newly allocated weight-balanced
tree.  The tree contains a single association, that of <VAR>datum</VAR> with
<VAR>key</VAR>.  <VAR>Wt-tree-type</VAR> is a weight-balanced tree type obtained
by calling <CODE>make-wt-tree-type</CODE>; the returned tree has this type.
</DL>
</P><P>

<A NAME="IDX1515"></A>
<DL>
<DT><U>procedure+:</U> <B>alist-&#62;wt-tree</B> <I>tree-type alist</I>
<DD>Returns a newly allocated weight-balanced tree that contains the same
associations as <VAR>alist</VAR>.  This procedure is equivalent to:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (type alist)
  (let ((tree (make-wt-tree type)))
    (for-each (lambda (association)
                (wt-tree/add! tree
                              (car association)
                              (cdr association)))
              alist)
    tree))
</pre></td></tr></table></DL>
</P><P>

<A NAME="Basic Operations on Weight-Balanced Trees"></A>
<HR SIZE="6">
<A NAME="SEC117"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC116"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC118"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC115"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.7.2 Basic Operations on Weight-Balanced Trees </H3>
<!--docid::SEC117::-->
<P>

This section describes the basic tree operations on weight-balanced
trees.  These operations are the usual tree operations for insertion,
deletion and lookup, some predicates and a procedure for determining the
number of associations in a tree.
</P><P>

<A NAME="IDX1516"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree?</B> <I>object</I>
<DD>Returns <CODE>#t</CODE> if <VAR>object</VAR> is a weight-balanced tree, otherwise
returns <CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1517"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/empty?</B> <I>wt-tree</I>
<DD>Returns <CODE>#t</CODE> if <VAR>wt-tree</VAR> contains no associations, otherwise
returns <CODE>#f</CODE>.
</DL>
</P><P>

<A NAME="IDX1518"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/size</B> <I>wt-tree</I>
<DD>Returns the number of associations in <VAR>wt-tree</VAR>, an exact
non-negative integer.  This operation takes constant time.
</DL>
</P><P>

<A NAME="IDX1519"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/add</B> <I>wt-tree key datum</I>
<DD>Returns a new tree containing all the associations in <VAR>wt-tree</VAR> and
the association of <VAR>datum</VAR> with <VAR>key</VAR>.  If <VAR>wt-tree</VAR> already
had an association for <VAR>key</VAR>, the new association overrides the old.
The average and worst-case times required by this operation are
proportional to the logarithm of the number of associations in
<VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1520"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/add!</B> <I>wt-tree key datum</I>
<DD>Associates <VAR>datum</VAR> with <VAR>key</VAR> in <VAR>wt-tree</VAR> and returns an
unspecified value.  If <VAR>wt-tree</VAR> already has an association for
<VAR>key</VAR>, that association is replaced.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1521"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/member?</B> <I>key wt-tree</I>
<DD>Returns <CODE>#t</CODE> if <VAR>wt-tree</VAR> contains an association for
<VAR>key</VAR>, otherwise returns <CODE>#f</CODE>.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1522"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/lookup</B> <I>wt-tree key default</I>
<DD>Returns the datum associated with <VAR>key</VAR> in <VAR>wt-tree</VAR>.  If
<VAR>wt-tree</VAR> doesn't contain an association for <VAR>key</VAR>,
<VAR>default</VAR> is returned.  The average and worst-case times required by
this operation are proportional to the logarithm of the number of
associations in <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1523"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/delete</B> <I>wt-tree key</I>
<DD>Returns a new tree containing all the associations in <VAR>wt-tree</VAR>,
except that if <VAR>wt-tree</VAR> contains an association for <VAR>key</VAR>, it
is removed from the result.  The average and worst-case times required
by this operation are proportional to the logarithm of the number of
associations in <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1524"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/delete!</B> <I>wt-tree key</I>
<DD>If <VAR>wt-tree</VAR> contains an association for <VAR>key</VAR> the association
is removed.  Returns an unspecified value.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="Advanced Operations on Weight-Balanced Trees"></A>
<HR SIZE="6">
<A NAME="SEC118"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC117"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC119"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC115"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.7.3 Advanced Operations on Weight-Balanced Trees </H3>
<!--docid::SEC118::-->
<P>

In the following the <EM>size</EM> of a tree is the number of associations
that the tree contains, and a <EM>smaller</EM> tree contains fewer
associations.
</P><P>

<A NAME="IDX1525"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/split&#60;</B> <I>wt-tree bound</I>
<DD>Returns a new tree containing all and only the associations in
<VAR>wt-tree</VAR> that have a key that is less than <VAR>bound</VAR> in the
ordering relation of the tree type of <VAR>wt-tree</VAR>.  The average and
worst-case times required by this operation are proportional to the
logarithm of the size of <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1526"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/split&#62;</B> <I>wt-tree bound</I>
<DD>Returns a new tree containing all and only the associations in
<VAR>wt-tree</VAR> that have a key that is greater than <VAR>bound</VAR> in the
ordering relation of the tree type of <VAR>wt-tree</VAR>.  The average and
worst-case times required by this operation are proportional to the
logarithm of the size of <VAR>wt-tree</VAR>.
</DL>
</P><P>

<A NAME="IDX1527"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/union</B> <I>wt-tree-1 wt-tree-2</I>
<DD>Returns a new tree containing all the associations from both trees.
This operation is asymmetric: when both trees have an association for
the same key, the returned tree associates the datum from <VAR>wt-tree-2</VAR>
with the key.  Thus if the trees are viewed as discrete maps then
<CODE>wt-tree/union</CODE> computes the map override of <VAR>wt-tree-1</VAR> by
<VAR>wt-tree-2</VAR>.  If the trees are viewed as sets the result is the set
union of the arguments.
The worst-case time required by this operation
is proportional to the sum of the sizes of both trees.
If the minimum key of one tree is greater than the maximum key of
the other tree then the worst-case time required is proportional to
the logarithm of the size of the larger tree.
</DL>
</P><P>

<A NAME="IDX1528"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/intersection</B> <I>wt-tree-1 wt-tree-2</I>
<DD>Returns a new tree containing all and only those associations from
<VAR>wt-tree-1</VAR> that have keys appearing as the key of an association
in <VAR>wt-tree-2</VAR>.  Thus the associated data in the result are those
from <VAR>wt-tree-1</VAR>.  If the trees are being used as sets the result is
the set intersection of the arguments.  As a discrete map operation,
<CODE>wt-tree/intersection</CODE> computes the domain restriction of
<VAR>wt-tree-1</VAR> to (the domain of) <VAR>wt-tree-2</VAR>.
The worst-case time required by this operation is proportional to
the sum of the sizes of the trees.
</DL>
</P><P>

<A NAME="IDX1529"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/difference</B> <I>wt-tree-1 wt-tree-2</I>
<DD>Returns a new tree containing all and only those associations from
<VAR>wt-tree-1</VAR> that have keys that <EM>do not</EM> appear as the key of
an association in <VAR>wt-tree-2</VAR>.  If the trees are viewed as sets the
result is the asymmetric set difference of the arguments.  As a discrete
map operation, it computes the domain restriction of <VAR>wt-tree-1</VAR> to
the complement of (the domain of) <VAR>wt-tree-2</VAR>.
The worst-case time required by this operation is proportional to
the sum of the sizes of the trees.
</DL>
</P><P>

<A NAME="IDX1530"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/subset?</B> <I>wt-tree-1 wt-tree-2</I>
<DD>Returns <CODE>#t</CODE> iff the key of each association in <VAR>wt-tree-1</VAR> is
the key of some association in <VAR>wt-tree-2</VAR>, otherwise returns <CODE>#f</CODE>.
Viewed as a set operation, <CODE>wt-tree/subset?</CODE> is the improper subset
predicate.
A proper subset predicate can be constructed:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (proper-subset? s1 s2)
  (and (wt-tree/subset? s1 s2)
       (&#60; (wt-tree/size s1) (wt-tree/size s2))))
</pre></td></tr></table></P><P>

As a discrete map operation, <CODE>wt-tree/subset?</CODE> is the subset
test on the domain(s) of the map(s).  In the worst-case the time
required by this operation is proportional to the size of
<VAR>wt-tree-1</VAR>.
</DL>
</P><P>

<A NAME="IDX1531"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/set-equal?</B> <I>wt-tree-1 wt-tree-2</I>
<DD>Returns <CODE>#t</CODE> iff for every association in <VAR>wt-tree-1</VAR> there is
an association in <VAR>wt-tree-2</VAR> that has the same key, and <EM>vice
versa</EM>.
</P><P>

Viewing the arguments as sets, <CODE>wt-tree/set-equal?</CODE> is the set
equality predicate.  As a map operation it determines if two maps are
defined on the same domain.
</P><P>

This procedure is equivalent to
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (wt-tree-1 wt-tree-2)
  (and (wt-tree/subset? wt-tree-1 wt-tree-2
       (wt-tree/subset? wt-tree-2 wt-tree-1)))
</pre></td></tr></table></P><P>

In the worst case the time required by this operation is proportional to
the size of the smaller tree.
</DL>
</P><P>

<A NAME="IDX1532"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/fold</B> <I>combiner initial wt-tree</I>
<DD>This procedure reduces <VAR>wt-tree</VAR> by combining all the associations,
using an reverse in-order traversal, so the associations are visited in
reverse order.  <VAR>Combiner</VAR> is a procedure of three arguments: a key,
a datum and the accumulated result so far.  Provided <VAR>combiner</VAR>
takes time bounded by a constant, <CODE>wt-tree/fold</CODE> takes time
proportional to the size of <VAR>wt-tree</VAR>.
</P><P>

A sorted association list can be derived simply:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(wt-tree/fold (lambda (key datum list)
                (cons (cons key datum) list))
              '()
              <VAR>wt-tree</VAR>))
</pre></td></tr></table></P><P>

The data in the associations can be summed like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(wt-tree/fold (lambda (key datum sum) (+ sum datum))
              0
              <VAR>wt-tree</VAR>)
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1533"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/for-each</B> <I>action wt-tree</I>
<DD>This procedure traverses <VAR>wt-tree</VAR> in order, applying <VAR>action</VAR> to
each association.
The associations are processed in increasing order of their keys.
<VAR>Action</VAR> is a procedure of two arguments that takes the key and
datum respectively of the association.
Provided <VAR>action</VAR> takes time bounded by a constant,
<CODE>wt-tree/for-each</CODE> takes time proportional to the size of
<VAR>wt-tree</VAR>.
The example prints the tree:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(wt-tree/for-each (lambda (key value)
                    (display (list key value)))
                  <VAR>wt-tree</VAR>))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1534"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/union-merge</B> <I>wt-tree-1 wt-tree-2 merge</I>
<DD>Returns a new tree containing all the associations from both trees.  If
both trees have an association for the same key, the datum associated
with that key in the result tree is computed by applying the procedure
<VAR>merge</VAR> to the key, the value from <VAR>wt-tree-1</VAR> and the value
from <VAR>wt-tree-2</VAR>.  <VAR>Merge</VAR> is of the form
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (<VAR>key</VAR> <VAR>datum-1</VAR> <VAR>datum-2</VAR>) ...)
</pre></td></tr></table></P><P>

If some key occurs only in one tree, that association will appear in the
result tree without being processed by <VAR>merge</VAR>, so for this
operation to make sense, either <VAR>merge</VAR> must have both a right and
left identity that correspond to the association being absent in one of
the trees, or some guarantee must be made, for example, all the keys in
one tree are known to occur in the other.
</P><P>

These are all reasonable procedures for <VAR>merge</VAR>
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (key val1 val2) (+ val1 val2))
(lambda (key val1 val2) (append val1 val2))
(lambda (key val1 val2) (wt-tree/union val1 val2))
</pre></td></tr></table></P><P>

However, a procedure like
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(lambda (key val1 val2) (- val1 val2))
</pre></td></tr></table></P><P>

would result in a subtraction of the data for all associations with keys
occuring in both trees but associations with keys occuring in only the
second tree would be copied, not negated, as is presumably be intent.
The programmer might ensure that this never happens.
</P><P>

This procedure has the same time behavior as <CODE>wt-tree/union</CODE> but
with a slightly worse constant factor.  Indeed, <CODE>wt-tree/union</CODE>
might have been defined like this:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (wt-tree/union tree1 tree2)
  (wt-tree/union-merge tree1 tree2
                       (lambda (key val1 val2) val2)))
</pre></td></tr></table></DL>
</P><P>

The <VAR>merge</VAR> procedure takes the <VAR>key</VAR> as a parameter in case the
data are not independent of the key.
</P><P>

<A NAME="Indexing Operations on Weight-Balanced Trees"></A>
<HR SIZE="6">
<A NAME="SEC119"></A>
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC118"> &lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC115"> Up </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<H3> 11.7.4 Indexing Operations on Weight-Balanced Trees </H3>
<!--docid::SEC119::-->
<P>

Weight-balanced trees support operations that view the tree as sorted
sequence of associations.  Elements of the sequence can be accessed by
position, and the position of an element in the sequence can be
determined, both in logarthmic time.
</P><P>

<A NAME="IDX1535"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/index</B> <I>wt-tree index</I>
<DD><A NAME="IDX1536"></A>
<DT><U>procedure+:</U> <B>wt-tree/index-datum</B> <I>wt-tree index</I>
<DD><A NAME="IDX1537"></A>
<DT><U>procedure+:</U> <B>wt-tree/index-pair</B> <I>wt-tree index</I>
<DD>Returns the 0-based <VAR>index</VAR>th association of <VAR>wt-tree</VAR> in the
sorted sequence under the tree's ordering relation on the keys.
<CODE>wt-tree/index</CODE> returns the <VAR>index</VAR>th key,
<CODE>wt-tree/index-datum</CODE> returns the datum associated with the
<VAR>index</VAR>th key and <CODE>wt-tree/index-pair</CODE> returns a new pair
<CODE>(<VAR>key</VAR> . <VAR>datum</VAR>)</CODE> which is the <CODE>cons</CODE> of the
<VAR>index</VAR>th key and its datum.  The average and worst-case times
required by this operation are proportional to the logarithm of the
number of associations in the tree.
</P><P>

These operations signal a condition of type
<CODE>condition-type:bad-range-argument</CODE> if <VAR>index</VAR><CODE>&#60;0</CODE> or if
<VAR>index</VAR> is greater than or equal to the number of associations in
the tree.  If the tree is empty, they signal an anonymous error.
</P><P>

Indexing can be used to find the median and maximum keys in the tree as
follows:
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>median:   (wt-tree/index <VAR>wt-tree</VAR>
                         (quotient (wt-tree/size <VAR>wt-tree</VAR>)
                                   2))
maximum:  (wt-tree/index <VAR>wt-tree</VAR>
                         (- (wt-tree/size <VAR>wt-tree</VAR>)
                            1))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1538"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/rank</B> <I>wt-tree key</I>
<DD>Determines the 0-based position of <VAR>key</VAR> in the sorted sequence of
the keys under the tree's ordering relation, or <CODE>#f</CODE> if the tree
has no association with for <VAR>key</VAR>.  This procedure returns either an
exact non-negative integer or <CODE>#f</CODE>.  The average and worst-case
times required by this operation are proportional to the logarithm of
the number of associations in the tree.
</DL>
</P><P>

<A NAME="IDX1539"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/min</B> <I>wt-tree</I>
<DD><A NAME="IDX1540"></A>
<DT><U>procedure+:</U> <B>wt-tree/min-datum</B> <I>wt-tree</I>
<DD><A NAME="IDX1541"></A>
<DT><U>procedure+:</U> <B>wt-tree/min-pair</B> <I>wt-tree</I>
<DD>Returns the association of <VAR>wt-tree</VAR> that has the least key under the tree's ordering relation.
<CODE>wt-tree/min</CODE> returns the least key,
<CODE>wt-tree/min-datum</CODE> returns the datum associated with the
least key and <CODE>wt-tree/min-pair</CODE> returns a new pair
<CODE>(key . datum)</CODE> which is the <CODE>cons</CODE> of the minimum key and its datum.
The average and worst-case times required by this operation are
proportional to the logarithm of the number of associations in the tree.
</P><P>

These operations signal an error if the tree is empty.
They could have been written
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(define (wt-tree/min tree)
  (wt-tree/index tree 0))
(define (wt-tree/min-datum tree)
  (wt-tree/index-datum tree 0))
(define (wt-tree/min-pair tree)
  (wt-tree/index-pair tree 0))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1542"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/delete-min</B> <I>wt-tree</I>
<DD>Returns a new tree containing all of the associations in <VAR>wt-tree</VAR>
except the association with the least key under the <VAR>wt-tree</VAR>'s
ordering relation.  An error is signalled if the tree is empty.  The
average and worst-case times required by this operation are proportional
to the logarithm of the number of associations in the tree.  This
operation is equivalent to
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(wt-tree/delete <VAR>wt-tree</VAR> (wt-tree/min <VAR>wt-tree</VAR>))
</pre></td></tr></table></DL>
</P><P>

<A NAME="IDX1543"></A>
<DL>
<DT><U>procedure+:</U> <B>wt-tree/delete-min!</B> <I>wt-tree</I>
<DD>Removes the association with the least key under the <VAR>wt-tree</VAR>'s
ordering relation.  An error is signalled if the tree is empty.  The
average and worst-case times required by this operation are proportional
to the logarithm of the number of associations in the tree.  This
operation is equivalent to
</P><P>

<TABLE><tr><td>&nbsp;</td><td class=example><pre>(wt-tree/delete! <VAR>wt-tree</VAR> (wt-tree/min <VAR>wt-tree</VAR>))
</pre></td></tr></table></DL>
</P><P>

<A NAME="Procedures"></A>
<HR SIZE="6">
<TABLE CELLPADDING=1 CELLSPACING=1 BORDER=0>
<TR><TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_12.html#SEC114"> &lt;&lt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_13.html#SEC120"> &gt;&gt; </A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT"> &nbsp; <TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme.html#SEC_Top">Top</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_toc.html#SEC_Contents">Contents</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_21.html#SEC216">Index</A>]</TD>
<TD VALIGN="MIDDLE" ALIGN="LEFT">[<A HREF="scheme_abt.html#SEC_About"> ? </A>]</TD>
</TR></TABLE>
<BR>  
<FONT SIZE="-1">
This document was generated
by <I>Chris Hanson</I> on <I>July, 18  2001</I>
using <A HREF="http://www.mathematik.uni-kl.de/~obachman/Texi2html
"><I>texi2html</I></A>

</BODY>
</HTML>
